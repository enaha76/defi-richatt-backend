/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { UserService } from "../user.service";
import { UserCreateInput } from "./UserCreateInput";
import { User } from "./User";
import { UserFindManyArgs } from "./UserFindManyArgs";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { UserUpdateInput } from "./UserUpdateInput";
import { ActivityFindManyArgs } from "../../activity/base/ActivityFindManyArgs";
import { Activity } from "../../activity/base/Activity";
import { ActivityWhereUniqueInput } from "../../activity/base/ActivityWhereUniqueInput";
import { DictionaryEntryFindManyArgs } from "../../dictionaryEntry/base/DictionaryEntryFindManyArgs";
import { DictionaryEntry } from "../../dictionaryEntry/base/DictionaryEntry";
import { DictionaryEntryWhereUniqueInput } from "../../dictionaryEntry/base/DictionaryEntryWhereUniqueInput";
import { AuditLogFindManyArgs } from "../../auditLog/base/AuditLogFindManyArgs";
import { AuditLog } from "../../auditLog/base/AuditLog";
import { AuditLogWhereUniqueInput } from "../../auditLog/base/AuditLogWhereUniqueInput";
import { CommentFindManyArgs } from "../../comment/base/CommentFindManyArgs";
import { Comment } from "../../comment/base/Comment";
import { CommentWhereUniqueInput } from "../../comment/base/CommentWhereUniqueInput";
import { DefinitionFindManyArgs } from "../../definition/base/DefinitionFindManyArgs";
import { Definition } from "../../definition/base/Definition";
import { DefinitionWhereUniqueInput } from "../../definition/base/DefinitionWhereUniqueInput";
import { ExampleFindManyArgs } from "../../example/base/ExampleFindManyArgs";
import { Example } from "../../example/base/Example";
import { ExampleWhereUniqueInput } from "../../example/base/ExampleWhereUniqueInput";
import { RootFindManyArgs } from "../../root/base/RootFindManyArgs";
import { Root } from "../../root/base/Root";
import { RootWhereUniqueInput } from "../../root/base/RootWhereUniqueInput";
import { AiSuggestionFindManyArgs } from "../../aiSuggestion/base/AiSuggestionFindManyArgs";
import { AiSuggestion } from "../../aiSuggestion/base/AiSuggestion";
import { AiSuggestionWhereUniqueInput } from "../../aiSuggestion/base/AiSuggestionWhereUniqueInput";
import { SubmissionFindManyArgs } from "../../submission/base/SubmissionFindManyArgs";
import { Submission } from "../../submission/base/Submission";
import { SubmissionWhereUniqueInput } from "../../submission/base/SubmissionWhereUniqueInput";
import { DocumentFindManyArgs } from "../../document/base/DocumentFindManyArgs";
import { Document } from "../../document/base/Document";
import { DocumentWhereUniqueInput } from "../../document/base/DocumentWhereUniqueInput";
import { UserBadgeFindManyArgs } from "../../userBadge/base/UserBadgeFindManyArgs";
import { UserBadge } from "../../userBadge/base/UserBadge";
import { UserBadgeWhereUniqueInput } from "../../userBadge/base/UserBadgeWhereUniqueInput";
import { UserRoleFindManyArgs } from "../../userRole/base/UserRoleFindManyArgs";
import { UserRole } from "../../userRole/base/UserRole";
import { UserRoleWhereUniqueInput } from "../../userRole/base/UserRoleWhereUniqueInput";

export class UserControllerBase {
  constructor(protected readonly service: UserService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: User })
  async createUser(@common.Body() data: UserCreateInput): Promise<User> {
    return await this.service.createUser({
      data: data,
      select: {
        createdAt: true,
        email: true,
        fullName: true,
        id: true,
        isActive: true,
        languageProficiency: true,
        lastLogin: true,
        level: true,
        passwordHash: true,
        points: true,
        profileImage: true,
        username: true,
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [User] })
  @ApiNestedQuery(UserFindManyArgs)
  async users(@common.Req() request: Request): Promise<User[]> {
    const args = plainToClass(UserFindManyArgs, request.query);
    return this.service.users({
      ...args,
      select: {
        createdAt: true,
        email: true,
        fullName: true,
        id: true,
        isActive: true,
        languageProficiency: true,
        lastLogin: true,
        level: true,
        passwordHash: true,
        points: true,
        profileImage: true,
        username: true,
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async user(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    const result = await this.service.user({
      where: params,
      select: {
        createdAt: true,
        email: true,
        fullName: true,
        id: true,
        isActive: true,
        languageProficiency: true,
        lastLogin: true,
        level: true,
        passwordHash: true,
        points: true,
        profileImage: true,
        username: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateUser(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() data: UserUpdateInput
  ): Promise<User | null> {
    try {
      return await this.service.updateUser({
        where: params,
        data: data,
        select: {
          createdAt: true,
          email: true,
          fullName: true,
          id: true,
          isActive: true,
          languageProficiency: true,
          lastLogin: true,
          level: true,
          passwordHash: true,
          points: true,
          profileImage: true,
          username: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteUser(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    try {
      return await this.service.deleteUser({
        where: params,
        select: {
          createdAt: true,
          email: true,
          fullName: true,
          id: true,
          isActive: true,
          languageProficiency: true,
          lastLogin: true,
          level: true,
          passwordHash: true,
          points: true,
          profileImage: true,
          username: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Get("/:id/activities")
  @ApiNestedQuery(ActivityFindManyArgs)
  async findActivities(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Activity[]> {
    const query = plainToClass(ActivityFindManyArgs, request.query);
    const results = await this.service.findActivities(params.id, {
      ...query,
      select: {
        activityDate: true,
        activityType: true,
        description: true,

        entry: {
          select: {
            id: true,
          },
        },

        id: true,
        pointsEarned: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/activities")
  async connectActivities(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ActivityWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      activities: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/activities")
  async updateActivities(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ActivityWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      activities: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/activities")
  async disconnectActivities(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ActivityWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      activities: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/approvedEntries")
  @ApiNestedQuery(DictionaryEntryFindManyArgs)
  async findApprovedEntries(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<DictionaryEntry[]> {
    const query = plainToClass(DictionaryEntryFindManyArgs, request.query);
    const results = await this.service.findApprovedEntries(params.id, {
      ...query,
      select: {
        approvalDate: true,

        approvalUser: {
          select: {
            id: true,
          },
        },

        audioFilePath: true,
        createdAt: true,

        creator: {
          select: {
            id: true,
          },
        },

        id: true,
        isChallengeWord: true,

        lastEditor: {
          select: {
            id: true,
          },
        },

        originType: true,
        partOfSpeech: true,

        root: {
          select: {
            id: true,
          },
        },

        status: true,
        transliteration: true,
        updatedAt: true,
        verbForm: true,
        word: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/approvedEntries")
  async connectApprovedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      approvedEntries: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/approvedEntries")
  async updateApprovedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      approvedEntries: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/approvedEntries")
  async disconnectApprovedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      approvedEntries: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/auditLogs")
  @ApiNestedQuery(AuditLogFindManyArgs)
  async findAuditLogs(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<AuditLog[]> {
    const query = plainToClass(AuditLogFindManyArgs, request.query);
    const results = await this.service.findAuditLogs(params.id, {
      ...query,
      select: {
        action: true,
        actionTime: true,
        details: true,
        entityId: true,
        entityType: true,
        id: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/auditLogs")
  async connectAuditLogs(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AuditLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      auditLogs: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/auditLogs")
  async updateAuditLogs(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AuditLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      auditLogs: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/auditLogs")
  async disconnectAuditLogs(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AuditLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      auditLogs: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/comments")
  @ApiNestedQuery(CommentFindManyArgs)
  async findComments(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Comment[]> {
    const query = plainToClass(CommentFindManyArgs, request.query);
    const results = await this.service.findComments(params.id, {
      ...query,
      select: {
        commentText: true,
        createdAt: true,

        entry: {
          select: {
            id: true,
          },
        },

        id: true,

        parentComment: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/comments")
  async connectComments(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: CommentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      comments: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/comments")
  async updateComments(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: CommentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      comments: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/comments")
  async disconnectComments(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: CommentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      comments: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/createdDefinitions")
  @ApiNestedQuery(DefinitionFindManyArgs)
  async findCreatedDefinitions(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Definition[]> {
    const query = plainToClass(DefinitionFindManyArgs, request.query);
    const results = await this.service.findCreatedDefinitions(params.id, {
      ...query,
      select: {
        createdAt: true,

        creator: {
          select: {
            id: true,
          },
        },

        definitionText: true,
        definitionType: true,

        entry: {
          select: {
            id: true,
          },
        },

        id: true,
        language: true,
        orderNumber: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/createdDefinitions")
  async connectCreatedDefinitions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DefinitionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdDefinitions: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/createdDefinitions")
  async updateCreatedDefinitions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DefinitionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdDefinitions: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/createdDefinitions")
  async disconnectCreatedDefinitions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DefinitionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdDefinitions: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/createdEntries")
  @ApiNestedQuery(DictionaryEntryFindManyArgs)
  async findCreatedEntries(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<DictionaryEntry[]> {
    const query = plainToClass(DictionaryEntryFindManyArgs, request.query);
    const results = await this.service.findCreatedEntries(params.id, {
      ...query,
      select: {
        approvalDate: true,

        approvalUser: {
          select: {
            id: true,
          },
        },

        audioFilePath: true,
        createdAt: true,

        creator: {
          select: {
            id: true,
          },
        },

        id: true,
        isChallengeWord: true,

        lastEditor: {
          select: {
            id: true,
          },
        },

        originType: true,
        partOfSpeech: true,

        root: {
          select: {
            id: true,
          },
        },

        status: true,
        transliteration: true,
        updatedAt: true,
        verbForm: true,
        word: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/createdEntries")
  async connectCreatedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdEntries: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/createdEntries")
  async updateCreatedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdEntries: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/createdEntries")
  async disconnectCreatedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdEntries: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/createdExamples")
  @ApiNestedQuery(ExampleFindManyArgs)
  async findCreatedExamples(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Example[]> {
    const query = plainToClass(ExampleFindManyArgs, request.query);
    const results = await this.service.findCreatedExamples(params.id, {
      ...query,
      select: {
        contextNotes: true,
        createdAt: true,

        creator: {
          select: {
            id: true,
          },
        },

        entry: {
          select: {
            id: true,
          },
        },

        exampleText: true,
        id: true,
        translation: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/createdExamples")
  async connectCreatedExamples(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ExampleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdExamples: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/createdExamples")
  async updateCreatedExamples(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ExampleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdExamples: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/createdExamples")
  async disconnectCreatedExamples(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ExampleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdExamples: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/createdRoots")
  @ApiNestedQuery(RootFindManyArgs)
  async findCreatedRoots(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Root[]> {
    const query = plainToClass(RootFindManyArgs, request.query);
    const results = await this.service.findCreatedRoots(params.id, {
      ...query,
      select: {
        challenge: {
          select: {
            id: true,
          },
        },

        classicalOrigin: true,
        createdAt: true,

        creator: {
          select: {
            id: true,
          },
        },

        id: true,
        isCompleted: true,
        notes: true,
        rootLetters: true,
        status: true,
        transliteration: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/createdRoots")
  async connectCreatedRoots(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: RootWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdRoots: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/createdRoots")
  async updateCreatedRoots(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: RootWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdRoots: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/createdRoots")
  async disconnectCreatedRoots(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: RootWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      createdRoots: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/editedEntries")
  @ApiNestedQuery(DictionaryEntryFindManyArgs)
  async findEditedEntries(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<DictionaryEntry[]> {
    const query = plainToClass(DictionaryEntryFindManyArgs, request.query);
    const results = await this.service.findEditedEntries(params.id, {
      ...query,
      select: {
        approvalDate: true,

        approvalUser: {
          select: {
            id: true,
          },
        },

        audioFilePath: true,
        createdAt: true,

        creator: {
          select: {
            id: true,
          },
        },

        id: true,
        isChallengeWord: true,

        lastEditor: {
          select: {
            id: true,
          },
        },

        originType: true,
        partOfSpeech: true,

        root: {
          select: {
            id: true,
          },
        },

        status: true,
        transliteration: true,
        updatedAt: true,
        verbForm: true,
        word: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/editedEntries")
  async connectEditedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      editedEntries: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/editedEntries")
  async updateEditedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      editedEntries: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/editedEntries")
  async disconnectEditedEntries(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DictionaryEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      editedEntries: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/reviewedSuggestions")
  @ApiNestedQuery(AiSuggestionFindManyArgs)
  async findReviewedSuggestions(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<AiSuggestion[]> {
    const query = plainToClass(AiSuggestionFindManyArgs, request.query);
    const results = await this.service.findReviewedSuggestions(params.id, {
      ...query,
      select: {
        createdAt: true,

        entry: {
          select: {
            id: true,
          },
        },

        examples: true,
        formType: true,
        id: true,
        reviewedAt: true,

        reviewer: {
          select: {
            id: true,
          },
        },

        root: {
          select: {
            id: true,
          },
        },

        status: true,
        suggestedDefinition: true,
        suggestedWord: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reviewedSuggestions")
  async connectReviewedSuggestions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AiSuggestionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviewedSuggestions: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reviewedSuggestions")
  async updateReviewedSuggestions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AiSuggestionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviewedSuggestions: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reviewedSuggestions")
  async disconnectReviewedSuggestions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AiSuggestionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviewedSuggestions: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/reviews")
  @ApiNestedQuery(SubmissionFindManyArgs)
  async findReviews(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Submission[]> {
    const query = plainToClass(SubmissionFindManyArgs, request.query);
    const results = await this.service.findReviews(params.id, {
      ...query,
      select: {
        entry: {
          select: {
            id: true,
          },
        },

        feedback: true,
        id: true,
        notes: true,
        reviewedAt: true,

        reviewer: {
          select: {
            id: true,
          },
        },

        status: true,
        submissionType: true,
        submittedAt: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reviews")
  async connectReviews(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SubmissionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviews: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reviews")
  async updateReviews(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SubmissionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviews: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reviews")
  async disconnectReviews(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SubmissionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviews: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/submissions")
  @ApiNestedQuery(SubmissionFindManyArgs)
  async findSubmissions(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Submission[]> {
    const query = plainToClass(SubmissionFindManyArgs, request.query);
    const results = await this.service.findSubmissions(params.id, {
      ...query,
      select: {
        entry: {
          select: {
            id: true,
          },
        },

        feedback: true,
        id: true,
        notes: true,
        reviewedAt: true,

        reviewer: {
          select: {
            id: true,
          },
        },

        status: true,
        submissionType: true,
        submittedAt: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/submissions")
  async connectSubmissions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SubmissionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      submissions: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/submissions")
  async updateSubmissions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SubmissionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      submissions: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/submissions")
  async disconnectSubmissions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SubmissionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      submissions: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/uploadedDocuments")
  @ApiNestedQuery(DocumentFindManyArgs)
  async findUploadedDocuments(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Document[]> {
    const query = plainToClass(DocumentFindManyArgs, request.query);
    const results = await this.service.findUploadedDocuments(params.id, {
      ...query,
      select: {
        documentName: true,
        documentType: true,
        filePath: true,
        id: true,
        language: true,
        newWordCount: true,
        processingStatus: true,
        uploadedAt: true,

        uploader: {
          select: {
            id: true,
          },
        },

        wordCount: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/uploadedDocuments")
  async connectUploadedDocuments(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DocumentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      uploadedDocuments: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/uploadedDocuments")
  async updateUploadedDocuments(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DocumentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      uploadedDocuments: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/uploadedDocuments")
  async disconnectUploadedDocuments(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: DocumentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      uploadedDocuments: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/userBadges")
  @ApiNestedQuery(UserBadgeFindManyArgs)
  async findUserBadges(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<UserBadge[]> {
    const query = plainToClass(UserBadgeFindManyArgs, request.query);
    const results = await this.service.findUserBadges(params.id, {
      ...query,
      select: {
        badge: {
          select: {
            id: true,
          },
        },

        earnedAt: true,
        id: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/userBadges")
  async connectUserBadges(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserBadgeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userBadges: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/userBadges")
  async updateUserBadges(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserBadgeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userBadges: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/userBadges")
  async disconnectUserBadges(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserBadgeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userBadges: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/userRoles")
  @ApiNestedQuery(UserRoleFindManyArgs)
  async findUserRoles(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<UserRole[]> {
    const query = plainToClass(UserRoleFindManyArgs, request.query);
    const results = await this.service.findUserRoles(params.id, {
      ...query,
      select: {
        assignedAt: true,
        id: true,

        role: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/userRoles")
  async connectUserRoles(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserRoleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userRoles: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/userRoles")
  async updateUserRoles(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserRoleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userRoles: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/userRoles")
  async disconnectUserRoles(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserRoleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userRoles: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }
}
